# [251219_PGS_Impl_Lv1_동영상_재생기]
> [문제 출처](https://school.programmers.co.kr/learn/courses/30/lessons/340213) <br/>

## 1. 🔍 분석 (10분)
- **제약 & 복잡도**:
   - N(commands) <= 100 -> O(N)
- **유형 & 자료구조**: Impl, List
- **핵심 로직 (Key Idea)**: 
   1. [전처리] 
      - 입력값을 변수에 할당(초기값) 
      - 입력값(시간)을 길이를 '초단위'로 변환 및 저장 ; mm:ss -> ss
   2. [메인 로직] (예외/탈출 조건 포함)
      - `현재 시간이 오프닝 시간 내에 있는지 확인` # commands 수행 전에 오프닝 시간 내에 있는지 최초 확인
         - `있으면 현재시간을 오프닝 종료시간으로 갱신`
      - for 문으로 commands의 인자를 순회 ; cmd
         - cmd 가 next 인 경우 
            - 현재 위치 10초 추가
            - 이때 현재 위치가 video_len - 10초 보다 큰 경우 ; 현재위치를 비디오 길이로 갱신
         - cmd 가 prev 인 경우 
            - 현재 위치 10초 뒤로
            - 이때 현재위치 < 10초 : 현재위치를 0초로 갱산
         - `현재 시간이 오프닝 시간 내에 있는지 확인` # commands 수행 후에 오프닝 시간 내에 있는지 확인 필요
            - `있으면 현재시간을 오프닝 종료시간으로 갱신`
      - 반복문이 종료된 후 초단위를 분:초 단위로 변경
         - `분:초 단위 변경시 한자리 수는 앞에 '0'을 추가해야함. (mm:ss)`
   3. [최종 결과] (return 값)
      - 분:초 단위로 변경된 최종 시간
- **체크 포인트**:
   - [x] N=1 또는 0일 때 (최소 입력) ; 최소 1개 이상의 commands
   - [x] 데이터가 없는 경우 (Empty) ; 없음
   - [x] 모든 값이 동일한 경우 ; 중복 상관없음
   - [x] 정답이 음수이거나 0일 가능성 ; 음수는 불가능, 0은 가능(시작 시간) -> 00:00
   - [x] 값의 변화가 특정 범위를 벗어나면 안 되는가? (Max/Min Check) ; 00:00 ~ 비디오 총 길이 안에 있어야 함. 

---

## 2. 📚 학습 (5분)
> 이 문제를 통해 새로 알게 된 점이나 다시 확인한 개념을 정리합니다.

**① 오늘의 알고리즘/개념**
> `단위 통일 (Unit Unification)` : 복합 단위(분:초)는 **가장 작은 단위(초)로 변환**하여 연산 후 복구하는 것이 실수 방지와 구현 단순화의 핵심.

**② Python Code Snippet (패턴 저장)**
> 시간 변환 및 0-padding 포맷팅
```python
# 1. 분:초(str) -> 초(int)
def to_sec(t):
    m, s = map(int, t.split(':'))
    return m * 60 + s

# 2. 초(int) -> 분:초(str)
def to_time(s):
    # f"{val:02d}" : 2자리 수로 맞추고 빈칸은 0으로 채움
    return f"{s // 60:02d}:{s % 60:02d}"

# 3. 값의 범위 제한 (Clamp pattern)
# pos = max(0, min(total_len, pos))
```

---

## 💡 참고 시트
> 유형, 자료구조, 복잡도, 체크 포인트를 정리합니다.

1. 🎯 목표 복잡도 가이드 (N의 크기 ➜ 시간 복잡도)
   - N ≤ 20     ➜ O(2^N)  : 백트래킹, 재귀, 완전탐색
   - N ≤ 1,000  ➜ O(N^2)  : 2중 For문, DP, 2차원 배열
   - N ≤ 10만   ➜ O(NlogN): 정렬, 힙, 이분탐색, 다익스트라, 유니온파인드
   - N ≤ 100만  ➜ O(N)    : 투 포인터, 그리디, DP, 스택/큐, 해시
-------------------------------------------------------
2. 🧩 알고리즘 유형 (파일명 약어)
   - [기본] Impl(구현), Sim(시뮬레이션), BF(브루트포스, 완전탐색)
   - [탐색] BFS(너비우선), DFS(깊이우선), Back(백트래킹), BinSearch(이분탐색)
   - [최적화] Greedy(그리디), DP(동적계획법)
   - [그래프] Dijkstra(다익스트라), Floyd(플로이드워셜), Topo(위상정렬), MST
   - [기타] TwoPtr(투 포인터), Sliding(슬라이딩 윈도우), Prime(소수판별)
-------------------------------------------------------
3. 📦 자료구조 선택
   - [선형] List(배열), Stack(스택), Queue(큐), Deque(덱)
   - [비선형] Graph(인접리스트/행렬), Tree(트리), Heap(우선순위 큐)
   - [검색/집합] Set(집합), Dictionary(해시맵)
-------------------------------------------------------
4. ⚠️ 필수 체크 포인트 (Edge Case)
   - [ ] N=1 또는 0일 때 (최소 입력)
   - [ ] 데이터가 없는 경우 (Empty)
   - [ ] 모든 값이 동일한 경우
   - [ ] 정답이 음수이거나 0일 가능성
   - [ ] 값의 변화가 특정 범위를 벗어나면 안 되는가? (Max/Min Check)
   - [ ] 재귀 깊이 제한 (sys.setrecursionlimit)
   - [ ] 리스트 복사 주의 (얕은 복사 vs 깊은 복사)
-------------------------------------------------------