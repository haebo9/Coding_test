# [251218_PGS_Impl_Lv1_붕대감기]
> [문제 출처](https://school.programmers.co.kr/learn/courses/30/lessons/250137) <br/>

## 1. 🔍 분석 (10분)
- **제약 & 복잡도**:
   - N(attacks) <= 100 -> O(N)
- **유형 & 자료구조**: Impl, list
- **핵심 로직 (Key Idea)**: 
   1. [전처리] 
      - [시전시간, 초당회복량, 추가회복량] 의 값이 담긴 bandage를 각각의 변수에 값을 할당 ; t, x, y
      - 입력받은 health 값을 h 변수에 초기화
      - 공격의 횟수를 n 변수에 할당(attacks 변수의 len 값) 
      - 이전의 공격 받았던 시간 초기화
   2. [메인 로직] (예외/탈출 조건 포함)
      - for 문을 통해 attacks의 인자를 하나씩 읽어옴. 
         - 공격 시간을 이전 공격 시간과 비교하여 얼마나 지났는지 확인 (공격 직전 시점으로 계산)
            - 지난 시간 만큼 초당 회복량 곱하여 h 값에 더함
            - 지난 시간을 시전시간으로 나눈 몫을 확인하여 그 값을 추가회복량에 곱해서 h 값에 더함
         - `최대 체력 제한 로직(수정됨)`
            - `h 값이 최대 체력(maxHealth)을 초과할 경우 maxHealth로 제한`
         - 공격 시점에서의 변수 갱신
            - h 값을 attacks의 피해량 만큼 빼줌
            - 공격 받은 시간 갱신
            - h 변수의 값(체력)이 0 이하기 되면 -1 반환 
      - 모든 반복문이 종료된 후의 결과를 answer 변수에 담음
   3. [최종 결과] (return 값)
      - 모든 반복문이 끝난 후의 최종 체력(answer)을 리턴 
- **체크 포인트**:
   - [x] 정답이 음수이거나 0일 가능성 : -1 반환 가능
   - [x] N=1 또는 0일 때 (최소 입력) : N=1인 경우에도 단 한번의 공격이 성사되고 종료(종료 조건이 모든 공격이 진행 or 체력 0이하)
   - [x] 데이터가 없는 경우 (Empty) : attacks 데이터는 반드시 1개 이상의 인자 포함
   - [x] 모든 값이 동일한 경우 ; attacks의 공격 시간은 모두 다름

---

## 2. 📚 학습 (5분)
> 이 문제를 통해 새로 알게 된 점이나 다시 확인한 개념을 정리합니다.

**① 오늘의 알고리즘/개념**
> **이산 사건 시뮬레이션 (Discrete Event Simulation)**
- 1초 단위(`step-by-step`)로 루프를 돌지 않고, **사건(공격) 발생 시점**으로 바로 건너뛰어(`Time Skip`) 변화량을 한 번에 계산하는 기법.
- `O(T)` (T:총 시간) 복잡도를 `O(N)` (N:이벤트 수)으로 획기적으로 줄일 수 있음.

**② Python Code Snippet (패턴 저장)**
> **값 제한(Clamping) & 시간 차 계산 패턴**
```python
# 1. 시간 차이(Time Diff)를 이용한 누적 계산
time_diff = current_time - last_time - 1
total_heal = time_diff * heal_per_sec

# 2. 값의 상한선 제한 (Clamping) -> if문 대신 min 사용
# if current_health > max_health: current_health = max_health (비추천)
current_health = min(max_health, current_health + total_heal) 
```

---

## 💡 참고 시트
> 유형, 자료구조, 복잡도, 체크 포인트를 정리합니다.

1. 🎯 목표 복잡도 가이드 (N의 크기 ➜ 시간 복잡도)
   - N ≤ 20     ➜ O(2^N)  : 백트래킹, 재귀, 완전탐색
   - N ≤ 1,000  ➜ O(N^2)  : 2중 For문, DP, 2차원 배열
   - N ≤ 10만   ➜ O(NlogN): 정렬, 힙, 이분탐색, 다익스트라, 유니온파인드
   - N ≤ 100만  ➜ O(N)    : 투 포인터, 그리디, DP, 스택/큐, 해시
-------------------------------------------------------
2. 🧩 알고리즘 유형 (파일명 약어)
   - [기본] Impl(구현), Sim(시뮬레이션), BF(브루트포스, 완전탐색)
   - [탐색] BFS(너비우선), DFS(깊이우선), Back(백트래킹), BinSearch(이분탐색)
   - [최적화] Greedy(그리디), DP(동적계획법)
   - [그래프] Dijkstra(다익스트라), Floyd(플로이드워셜), Topo(위상정렬), MST
   - [기타] TwoPtr(투 포인터), Sliding(슬라이딩 윈도우), Prime(소수판별)
-------------------------------------------------------
3. 📦 자료구조 선택
   - [선형] List(배열), Stack(스택), Queue(큐), Deque(덱)
   - [비선형] Graph(인접리스트/행렬), Tree(트리), Heap(우선순위 큐)
   - [검색/집합] Set(집합), Dictionary(해시맵)
-------------------------------------------------------
4. ⚠️ 필수 체크 포인트 (Edge Case)
   - [ ] N=1 또는 0일 때 (최소 입력)
   - [ ] 데이터가 없는 경우 (Empty)
   - [ ] 모든 값이 동일한 경우
   - [ ] 정답이 음수이거나 0일 가능성
   - [ ] int 범위를 넘는 경우 (Python은 걱정 덜 해도 됨)
-------------------------------------------------------