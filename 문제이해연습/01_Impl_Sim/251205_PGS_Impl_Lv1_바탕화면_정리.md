# [251205_PGS_Impl_Lv1_바탕화면_정리]
> [문제 출처](https://school.programmers.co.kr/learn/courses/30/lessons/161990) <br/>
> **파일 네이밍 규칙**: `YYMMDD_플랫폼_유형_난이도_제목.md`
> - **플랫폼**: BOJ(백준), PGS(프로그래머스), SEA(삼성SW), LTC(리트코드)
> - **유형**: Impl(구현), BFS, DFS, Greedy, DP, Stack, Queue, Hash 등
> - **난이도**: Lv1, G5(골드5), S3(실버3) 등
> - **예시**: `251205_PGS_Impl_Lv1_유연근무제.md`, `251205_BOJ_BFS_G5_토마토.md`

## 1. 🔍 분석 (10분)
- **제약 & 복잡도**:
    - wallpaper의 최대 크기 : 50*50 -> O(N^2)
    - wallpaper의[i][j]의 값은 '.' 또는 '#'으로 구성
    - 적어도 하나의 파일 있음.
- **유형 & 자료구조** : 구현, List
- **핵심 로직 (Key Idea)**: 
   - [전처리] 
      - wallpaper의 길이 n 내의 str 형태로 들어간 문자열을 2차원 리스트로 변환
      - NxN 크기의 2차원 리스트를 생성
   - [메인 로직] (예외/탈출 조건 포함)
      - x, y값을 기준으로 가장 왼쪽 위의 '#'의 좌표를 찾음
      - 가장 오른쪽 아래의 '#'의 좌표를 찾음
      - 두 좌표 값을 answer에 담음
   - [최종 결과] (return 값)
      - 시작점의 x, y, 종료점의 x, y 순서대로 담은 리스트 반환
- **체크 포인트**:
    - [ ] [참고 시트에서 선택]

---

## 2. 📚 학습 (5분)
> 이 문제를 통해 새로 알게 된 점이나 다시 확인한 개념을 정리합니다.

**① 오늘의 알고리즘/개념**
> 개념의 핵심 원리 한 줄 요약
   - [전처리] wallpaper의 길이 n 내의 str 형태로 들어간 문자열을 2차원 리스트로 변환 
      - str도 인덱스 접근이 가능하다는 것을 생각 : 2차원 배열로 변환 불필요
   - [메인 로직] x, y값을 기준으로 가장 왼쪽 위의 '#'의 좌표를 찾음
      - (x+1, y+1) 까지의 값을 포함해야 함
   - 드레그한 거리 계산 로직을 구현해야 함. (드레그 거리 최소화)
      - 점 S(lux, luy)에서 점 E(rdx, rdy)로 드래그를 할 때, 
      - 드래그 한 거리: |rdx - lux| + |rdy - luy| 

**② Python Code Snippet (패턴 저장)**
> 나중에 써먹을 수 있는 핵심 코드 조각
```python
# 2차원 격자에서 특정 문자의 최소/최대 범위(Bounding Box) 구하기
lux, luy = float('inf'), float('inf') # 최소값은 무한대로 초기화
rdx, rdy = 0, 0                       # 최대값은 0으로 초기화

for r in range(len(wallpaper)):
    for c in range(len(wallpaper[0])):
        if wallpaper[r][c] == '#':
            lux = min(lux, r)
            luy = min(luy, c)
            rdx = max(rdx, r + 1) # 드래그 끝점은 해당 좌표 + 1
            rdy = max(rdy, c + 1)
```

## 💡 참고 시트
> 유형, 자료구조, 복잡도, 체크 포인트를 정리합니다.

1. 🎯 목표 복잡도 가이드 (N의 크기 ➜ 시간 복잡도)
   - N ≤ 20     ➜ O(2^N)  : 백트래킹, 재귀, 완전탐색
   - N ≤ 1,000  ➜ O(N^2)  : 2중 For문, DP, 2차원 배열
   - N ≤ 10만   ➜ O(NlogN): 정렬, 힙, 이분탐색, 다익스트라, 유니온파인드
   - N ≤ 100만  ➜ O(N)    : 투 포인터, 그리디, DP, 스택/큐, 해시
-------------------------------------------------------
2. 🧩 알고리즘 유형 (파일명 약어)
   - [기본] Impl(구현), Sim(시뮬레이션), BF(브루트포스, 완전탐색)
   - [탐색] BFS(너비우선), DFS(깊이우선), Back(백트래킹), BinSearch(이분탐색)
   - [최적화] Greedy(그리디), DP(동적계획법)
   - [그래프] Dijkstra(다익스트라), Floyd(플로이드워셜), Topo(위상정렬), MST
   - [기타] TwoPtr(투 포인터), Sliding(슬라이딩 윈도우), Prime(소수판별)
-------------------------------------------------------
3. 📦 자료구조 선택
   - [선형] List(배열), Stack(스택), Queue(큐), Deque(덱)
   - [비선형] Graph(인접리스트/행렬), Tree(트리), Heap(우선순위 큐)
   - [검색/집합] Set(집합), Dictionary(해시맵)
-------------------------------------------------------
4. ⚠️ 필수 체크 포인트 (Edge Case)
   - [ ] N=1 또는 0일 때 (최소 입력)
   - [ ] 데이터가 없는 경우 (Empty)
   - [ ] 모든 값이 동일한 경우
   - [ ] 정답이 음수이거나 0일 가능성
   - [ ] int 범위를 넘는 경우 (Python은 걱정 덜 해도 됨)
-------------------------------------------------------