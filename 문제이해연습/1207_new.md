# [241207_PGS_Impl_Lv2_가장_많이_받은_선물]
> [문제 출처](https://school.programmers.co.kr/learn/courses/30/lessons/258712) <br/>
> **파일 네이밍 규칙**: `YYMMDD_플랫폼_유형_난이도_제목.md`
> - **플랫폼**: BOJ(백준), PGS(프로그래머스), SEA(삼성SW), LTC(리트코드)
> - **유형**: Impl(구현), BFS, DFS, Greedy, DP, Stack, Queue, Hash 등
> - **난이도**: Lv1, G5(골드5), S3(실버3) 등
> - **예시**: `251205_PGS_Impl_Lv1_유연근무제.md`, `251205_BOJ_BFS_G5_토마토.md`

## 1. 🔍 분석 (10분)
- **제약 & 복잡도**:
   - Friends(N) ≤ 50 (매우 작음) ➜ **O(N²)** 가능
   - Gifts(M) ≤ 10,000 ➜ **O(M)** (전처리)
   - 전체 시간 복잡도: **O(M + N²)**
- **유형 & 자료구조**: impl(구현)
   - HashMap (이름 → 인덱스 매핑)
   - 2D List (주고받은 선물 내역)
- **핵심 로직 (Key Idea)**: 
   1. [전처리] 
      - 친구 이름별 인덱스 매핑 (ex: `{"muzi": 0, "ryan": 1 ...}`)
      - `gift_graph[N][N]`: A가 B에게 준 선물 개수 기록
      - `gift_index[N]`: 선물 지수 (준 선물 - 받은 선물) 계산
   2. [메인 로직] (이중 루프 i, j)
      - 두 사람(i, j) 간의 관계 확인 (i != j)
      - IF `gift_graph[i][j] > gift_graph[j][i]`: i가 선물 +1
      - IF `주고받은 개수가 같거나(0포함)`:
         - IF `gift_index[i] > gift_index[j]`: i가 선물 +1
         - ELSE: 선물 없음
   3. [최종 결과]
      - 각 인원별 받을 선물 갯수(`next_month_gifts[N]`) 중 최댓값 반환
- **체크 포인트**:
   - [ ] 이름(String) ➜ 인덱스(Integer) 매핑 필요
   - [ ] 자기 자신과의 비교 제외 (i != j)

---

## 2. 📚 학습 (5분)
> 이 문제를 통해 새로 알게 된 점이나 다시 확인한 개념을 정리합니다.

**① 오늘의 알고리즘/개념**
> 개념의 핵심 원리 한 줄 요약
- 서로 주고 받는 관계에서 어디 쪽이 더 많은 지 확인 하는 로직
   - 이중 리스트를 만들고, [i][j]와 [j][i]를 비교하여 더 많은 쪽을 +1
- 인덱스 매핑을 통해 리스트 index 순환을 쉽게 만들수 있음 

**② Python Code Snippet (패턴 저장)**
> 나중에 써먹을 수 있는 핵심 코드 조각
```python
# 친구 이름 -> 인덱스 매핑
name_to_idx = {name: i for i, name in enumerate(friends)}

# 선물 주고받은 내역
graph = [[0] * N for _ in range(N)]
```

## 💡 참고 시트
> 유형, 자료구조, 복잡도, 체크 포인트를 정리합니다.

1. 🎯 목표 복잡도 가이드 (N의 크기 ➜ 시간 복잡도)
   - N ≤ 20     ➜ O(2^N)  : 백트래킹, 재귀, 완전탐색
   - N ≤ 1,000  ➜ O(N^2)  : 2중 For문, DP, 2차원 배열
   - N ≤ 10만   ➜ O(NlogN): 정렬, 힙, 이분탐색, 다익스트라, 유니온파인드
   - N ≤ 100만  ➜ O(N)    : 투 포인터, 그리디, DP, 스택/큐, 해시
-------------------------------------------------------
2. 🧩 알고리즘 유형 (파일명 약어)
   - [기본] Impl(구현), Sim(시뮬레이션), BF(브루트포스, 완전탐색)
   - [탐색] BFS(너비우선), DFS(깊이우선), Back(백트래킹), BinSearch(이분탐색)
   - [최적화] Greedy(그리디), DP(동적계획법)
   - [그래프] Dijkstra(다익스트라), Floyd(플로이드워셜), Topo(위상정렬), MST
   - [기타] TwoPtr(투 포인터), Sliding(슬라이딩 윈도우), Prime(소수판별)
-------------------------------------------------------
3. 📦 자료구조 선택
   - [선형] List(배열), Stack(스택), Queue(큐), Deque(덱)
   - [비선형] Graph(인접리스트/행렬), Tree(트리), Heap(우선순위 큐)
   - [검색/집합] Set(집합), Dictionary(해시맵)
-------------------------------------------------------
4. ⚠️ 필수 체크 포인트 (Edge Case)
   - [ ] N=1 또는 0일 때 (최소 입력)
   - [ ] 데이터가 없는 경우 (Empty)
   - [ ] 모든 값이 동일한 경우
   - [ ] 정답이 음수이거나 0일 가능성
   - [ ] int 범위를 넘는 경우 (Python은 걱정 덜 해도 됨)
-------------------------------------------------------