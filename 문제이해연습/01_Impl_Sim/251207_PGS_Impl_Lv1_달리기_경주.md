# [251207_PGS_Impl_Lv1_달리기_경주]
> [문제 출처](https://school.programmers.co.kr/learn/courses/30/lessons/178871) <br/>
> **파일 네이밍 규칙**: `YYMMDD_플랫폼_유형_난이도_제목.md`
> - **플랫폼**: BOJ(백준), PGS(프로그래머스), SEA(삼성SW), LTC(리트코드)
> - **유형**: Impl(구현), BFS, DFS, Greedy, DP, Stack, Queue, Hash 등
> - **난이도**: Lv1, G5(골드5), S3(실버3) 등
> - **예시**: `251205_PGS_Impl_Lv1_유연근무제.md`

## 1. 🔍 분석 (10분)
- **제약 & 복잡도**:
   - M(players) <= 50,000 -> O(M) 
   - N(caliings) <= 1,000,000 -> O(N)
   - 전체 시간복잡도 -> O(M+N)
- **유형 & 자료구조**: Impl
- **핵심 로직 (Key Idea)**: 
   1. [전처리] 
      - players의 이름을 key, 인덱스 값을 value로 하는 players_dict 생성
   2. [메인 로직] (예외/탈출 조건 포함) : 순서 변경 및 위치 갱신
      - callings의 값을 앞에 부터 순회
         - 요소(players 이름)를 players_dict 키에서 조회한다.
      - 조회한 값(=리스트 내 인덱스)으로 리스트에 접근 
         - players에서 해당 인덱스의 값과 그 앞의 값을 바꾼다. -> O(1)
      - 딕셔너리를 갱신
         - 딕셔너리에서 앞에서 call된 이름의 value를 -1
         - 순서변경 후 리스트에서 동일한 인덱스의 위치를 다시 조회하고
         - 조회된 이름을 key로 사용하여 해당 선수의 value를 +1
      - callings 리스트의 모든 요소를 순회한 후 players 리스트를 반환
   3. [최종 결과] (return 값)
       - 최종 players 리스트
- **체크 포인트**:
   - [ ] 맨 앞 순위의 선수는 불리지 않음
   - [ ] 선수 이름의 중복은 없고, 알파벳 소문자로만 이루어짐
   - [ ] calling이 비게되면 종료 및 순위 리턴 

---

## 2. 📚 학습 (5분)
> 이 문제를 통해 새로 알게 된 점이나 다시 확인한 개념을 정리합니다.

**① 오늘의 알고리즘/개념**
> 개념의 핵심 원리 한 줄 요약
- Hash search vs List search
   - Hash search: O(1) : 키를 해시 함수(딕셔너리)에 넣어 바로 계산
   - List search: O(N) : 리스트에서 순차적으로 찾음
   - 대량의 탐색이 필요한 경우 반드시 딕셔너리로 인덱스를 캐싱(Caching)한다. 
- Data Synchronization (데이터 동기화)
   - 리스트(순서)와 딕셔너리(위치 정보)를 동시에 관리할 때
   - 변경이 일어날 때 두 자료구조 모두 즉시 갱신하여 정합성을 유지하는 것이 중요하다.

**② Python Code Snippet (패턴 저장)**
> 나중에 써먹을 수 있는 핵심 코드 조각
```python
# pythonic way : enumerate 
## 딕셔너리 인덱스 캐싱
name_to_idx = {name: i for i, name in enumerate(players)}
```

---
## 💡 참고 시트
> 유형, 자료구조, 복잡도, 체크 포인트를 정리합니다.

1. 🎯 목표 복잡도 가이드 (N의 크기 ➜ 시간 복잡도)
   - N ≤ 20     ➜ O(2^N)  : 백트래킹, 재귀, 완전탐색
   - N ≤ 1,000  ➜ O(N^2)  : 2중 For문, DP, 2차원 배열
   - N ≤ 10만   ➜ O(NlogN): 정렬, 힙, 이분탐색, 다익스트라, 유니온파인드
   - N ≤ 100만  ➜ O(N)    : 투 포인터, 그리디, DP, 스택/큐, 해시
-------------------------------------------------------
2. 🧩 알고리즘 유형 (파일명 약어)
   - [기본] Impl(구현), Sim(시뮬레이션), BF(브루트포스, 완전탐색)
   - [탐색] BFS(너비우선), DFS(깊이우선), Back(백트래킹), BinSearch(이분탐색)
   - [최적화] Greedy(그리디), DP(동적계획법)
   - [그래프] Dijkstra(다익스트라), Floyd(플로이드워셜), Topo(위상정렬), MST
   - [기타] TwoPtr(투 포인터), Sliding(슬라이딩 윈도우), Prime(소수판별)
-------------------------------------------------------
3. 📦 자료구조 선택
   - [선형] List(배열), Stack(스택), Queue(큐), Deque(덱)
   - [비선형] Graph(인접리스트/행렬), Tree(트리), Heap(우선순위 큐)
   - [검색/집합] Set(집합), Dictionary(해시맵)
-------------------------------------------------------
4. ⚠️ 필수 체크 포인트 (Edge Case)
   - [ ] N=1 또는 0일 때 (최소 입력)
   - [ ] 데이터가 없는 경우 (Empty)
   - [ ] 모든 값이 동일한 경우
   - [ ] 정답이 음수이거나 0일 가능성
   - [ ] int 범위를 넘는 경우 (Python은 걱정 덜 해도 됨)
-------------------------------------------------------